<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Security Research on SPERIXLABS</title>
    <link>https://sperixlabs.org/tags/security-research/</link>
    <description>Recent content in Security Research on SPERIXLABS</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>SPERIXLABS</copyright>
    <lastBuildDate>Mon, 16 Feb 2026 12:00:00 +0000</lastBuildDate>
    <atom:link href="https://sperixlabs.org/tags/security-research/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ollama-Forge for Security Research: Local Models, Refusal Ablation, and Reproducible Pipelines</title>
      <link>https://sperixlabs.org/post/2026/02/ollama-forge-for-security-research-local-models-refusal-ablation-and-reproducible-pipelines/</link>
      <pubDate>Mon, 16 Feb 2026 12:00:00 +0000</pubDate>
      <guid>https://sperixlabs.org/post/2026/02/ollama-forge-for-security-research-local-models-refusal-ablation-and-reproducible-pipelines/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;Security work often involves prompts and data you cannot send to commercial APIs: malware descriptions, exploit drafts, jailbreak and prompt-injection tests, or sensitive internal docs. Running models locally gives you control and keeps that data on your machine. &lt;a href=&#34;https://pypi.org/project/ollama-forge/&#34;&gt;&lt;strong&gt;ollama-forge&lt;/strong&gt;&lt;/a&gt; is a CLI (&lt;a href=&#34;https://pypi.org/project/ollama-forge/&#34;&gt;PyPI&lt;/a&gt; · &lt;a href=&#34;https://github.com/jayluxferro/ollama-forge&#34;&gt;GitHub&lt;/a&gt;) that makes it straightforward to fetch open-weight models, convert them to &lt;a href=&#34;https://ollama.com&#34;&gt;Ollama&lt;/a&gt;, remove refusal behavior when you need it for defensive or red-team research, run security evals (e.g. ASR, refusal rate) against your local model, and lock down exact setups for reproducibility.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unlocking the Vault: A Deep Dive into macOS ARM64 Trial Enforcement and Binary Patching</title>
      <link>https://sperixlabs.org/post/2026/02/unlocking-the-vault-a-deep-dive-into-macos-arm64-trial-enforcement-and-binary-patching/</link>
      <pubDate>Sun, 01 Feb 2026 10:19:53 +0000</pubDate>
      <guid>https://sperixlabs.org/post/2026/02/unlocking-the-vault-a-deep-dive-into-macos-arm64-trial-enforcement-and-binary-patching/</guid>
      <description>&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&#xA;&lt;p&gt;In the course of analyzing a decompiled macOS productivity application—a calendar and meeting alert utility with a time-limited trial—we encountered a multi-layered enforcement mechanism governing trial expiry, feature gating, and application termination. This practice is common in commercial software: when the trial expires, the app displays warnings, disables premium features, and eventually terminates unless the user purchases or restores a license.&lt;/p&gt;&#xA;&lt;p&gt;This article documents the complete reverse engineering journey: from initial string reconnaissance through call-graph tracing, assembly-level analysis, and ultimately the development of six binary patches that bypass trial termination, re-enable gated features, and customize the UI—all without modifying the application&amp;rsquo;s source code or runtime environment.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
